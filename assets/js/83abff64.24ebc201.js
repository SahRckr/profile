"use strict";(self.webpackChunkprofile=self.webpackChunkprofile||[]).push([[809],{2447:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=s(5893),r=s(1151);const o={slug:"promises-polyfill",title:"A comprehensive guide on Promise polyfills",description:"Promise, Promise.all, Promise.resolve, Promise.reject, Promise.race, Promise.allSettled",author:"Sahil Satishkumar",author_url:"https://sahilsatishkumar.dev/contact",author_image_url:"https://avatars1.githubusercontent.com/u/8242514",tags:["javascript","polyfills"]},i=void 0,l={permalink:"/blog/promises-polyfill",source:"@site/blog/2024-01-13-promises-polyfill.md",title:"A comprehensive guide on Promise polyfills",description:"Promise, Promise.all, Promise.resolve, Promise.reject, Promise.race, Promise.allSettled",date:"2024-01-13T00:00:00.000Z",formattedDate:"January 13, 2024",tags:[{label:"javascript",permalink:"/blog/tags/javascript"},{label:"polyfills",permalink:"/blog/tags/polyfills"}],readingTime:6.915,hasTruncateMarker:!0,authors:[{name:"Sahil Satishkumar",url:"https://sahilsatishkumar.dev/contact",imageURL:"https://avatars1.githubusercontent.com/u/8242514"}],frontMatter:{slug:"promises-polyfill",title:"A comprehensive guide on Promise polyfills",description:"Promise, Promise.all, Promise.resolve, Promise.reject, Promise.race, Promise.allSettled",author:"Sahil Satishkumar",author_url:"https://sahilsatishkumar.dev/contact",author_image_url:"https://avatars1.githubusercontent.com/u/8242514",tags:["javascript","polyfills"]},unlisted:!1,nextItem:{title:"Welcome 2024!",permalink:"/blog/2024"}},a={authorsImageUrls:[void 0]},c=[{value:"Topics covered",id:"topics-covered",level:2},{value:"<code>new Promise(cb)</code>",id:"new-promisecb",level:3},{value:"<code>Promise.resolve</code>",id:"promiseresolve",level:3},{value:"<code>Promise.reject</code>",id:"promisereject",level:3},{value:"<code>Promise.withResolvers</code>",id:"promisewithresolvers",level:3},{value:"<code>Promise.race</code>",id:"promiserace",level:3},{value:"<code>Promise.all</code>",id:"promiseall",level:3},{value:"<code>Promise.any</code>",id:"promiseany",level:3},{value:"<code>Promise.allSettled</code>",id:"promiseallsettled",level:3},{value:"Resources",id:"resources",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"My intention here is to write a one-stop article to summarise how one would write all the polyfills for Promise and its static methods."}),"\n",(0,n.jsx)(t.h2,{id:"topics-covered",children:"Topics covered"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#new-promisecb",children:(0,n.jsx)(t.code,{children:"new Promise(cb)"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promiseresolve",children:(0,n.jsx)(t.code,{children:"Promise.resolve"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promisereject",children:(0,n.jsx)(t.code,{children:"Promise.reject"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promisewithresolvers",children:(0,n.jsx)(t.code,{children:"Promise.withResolvers"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promiserace",children:(0,n.jsx)(t.code,{children:"Promise.race"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promiseany",children:(0,n.jsx)(t.code,{children:"Promise.any"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#promiseallsettled",children:(0,n.jsx)(t.code,{children:"Promise.allSettled"})})}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"new-promisecb",children:(0,n.jsx)(t.code,{children:"new Promise(cb)"})}),"\n",(0,n.jsx)(t.p,{children:"Here's what a typical promise syntax looks like:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:'const transaction = new Promise((resolve, reject) => {\n\ttry {\n\t\t...\n\t\t// do something async\n\t\t...\n\t\tif(success) {\n\t\t\tresolve("\ud83d\udcb0\ud83d\udcb0\ud83d\udcb0")\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err)\n\t\treject("Transaction failed")\n\t}\n\t\n\tif(somethingWrong){\n\t\treject("Transaction failed")\n\t}\n})\n.then(console.log) // logs "\ud83d\udcb0\ud83d\udcb0\ud83d\udcb0" if succeeds.\n.catch(console.error) // error-logs "Transaction failed" if fails.\n'})}),"\n",(0,n.jsx)(t.p,{children:"from the syntax about, i hope it's pretty clear that this should be the skeleton of the polyfill class"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"class MyPromise {\n\tconstructor(callback){\n\t\t// do something here\n\t\t// pass the resolve/reject handlers to the callback\n\t}\n\t\n\tthen(thenHandler){\n\t\t// do something with the then callback\n\t\treturn this; // do not forget this\n\t}\n\t\n\tcatch(catchHandler){\n\t\t// do something with the catch callback\n\t\treturn this;\n\t\t// Must if you want MyPromise to support `finally` cycle\n\t}\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["let's zoom into what is needed in the ",(0,n.jsx)(t.code,{children:"constructor"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"{5-7} showLineNumbers",children:"class MyPromise {\n\tconstructor(callback){\n\t\t// at some point we need to call the callback\n\t\t// and provide it the resolve & reject handlers\n\t\tfunction resolve(val) { // do something with val }\n\t\tfunction reject(err) { // do something with err }\n\t\tcallback(resolve, reject);\n\t}\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["New challenge, to complete the ",(0,n.jsx)(t.code,{children:"resolve"})," and ",(0,n.jsx)(t.code,{children:"reject"})," functions, we need to provide it with the ",(0,n.jsx)(t.code,{children:"thenHandler"})," and the ",(0,n.jsx)(t.code,{children:"catchHandler"}),". Because I've already used a class notation, I can hold these in some class fields."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"{2,3,10,15} showLineNumbers",children:"class MyPromise {\n\tonResolve;\n\tonReject;\n\t\n\tconstructor(callback){\n\t\t// same as before\n\t}\n\t\n\tthen(thenHandler){\n\t\tthis.onResolve = thenHandler;\n\t\treturn this;\n\t}\n\t\n\tcatch(catchHandler){\n\t\tthis.onReject = catchHandler;\n\t\treturn this;\n\t}\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["There is a connection we are missing. When we call the ",(0,n.jsx)(t.code,{children:"onResolve"})," or ",(0,n.jsx)(t.code,{children:"onReject"})," callbacks, we need to provide these callbacks a value, however, the value would be available only in the constructor. So we need to add two more class fields to hold those values."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"{4,5,9,12} showLineNumbers",children:"class MyPromise {\n\tonResolve;\n\tonReject;\n\tvalue;\n\terror;\n\t\n\tconstructor(callback){\n\t\tfunction resolve(val) {\n\t\t\tthis.value = val;\n\t\t}\n\t\tfunction reject(err) {\n\t\t\tthis.error = err;\n\t\t}\n\t\tcallback(resolve, reject)\n\t}\n\t// same as before\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Guess what, we've opened another can of worms, when & where do we call our ",(0,n.jsx)(t.code,{children:"onResolve"})," and ",(0,n.jsx)(t.code,{children:"onReject"})," callbacks? Think opportunistically, and you'll see you got to do this both at the constructors and member functions. Because of this, we need to also maintain a state for promise being called, rejected or resolved. Now we have all the right ingredients."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"{6-8,12,15-18,21,23-26,33-36,42-45} showLineNumbers",children:"class MyPromise {\n\tonResolve;\n\tonReject;\n\tvalue;\n\terror;\n\tisFulfilled = false;\n\tisRejected = false;\n\tisCalled = false;\n\t\n\tconstructor(callback){\n\t\tfunction resolve(val) {\n\t\t\tthis.isFulfilled = true;\n\t\t\tthis.value = val;\n\t\t\t// Safety check to confirm that onResolve is set\n\t\t\tif(typeof this.onResolve === 'function' && !this.isCalled) {\n\t\t\t\tthis.isCalled = true;\n\t\t\t\tthis.onResolve(val);\n\t\t\t}\n\t\t}\n\t\tfunction reject(err) {\n\t\t\tthis.isRejected = true;\n\t\t\tthis.error = err;\n\t\t\tif(typeof this.onReject === 'function' && !this.isCalled) {\n\t\t\t\tthis.isCalled = true;\n\t\t\t\tthis.onReject(err);\n\t\t\t}\n\t\t}\n\t\tcallback(resolve, reject);\n\t}\n\t\n\tthen(thenHandler){\n\t\tthis.onResolve = thenHandler;\n\t\tif(!this.isCalled && this.isFulfilled) {\n\t\t\tthis.isCalled = true;\n\t\t\tthis.onResolve(this.value); // OR thenHandler(this.value)\n\t\t}\n\t\treturn this\n\t}\n\n\tcatch(catchHandler){\n\t\tthis.onReject = catchHandler;\n\t\tif(!this.isCalled && this.isRejected) {\n\t\t\tthis.isCalled = true;\n\t\t\tthis.onReject(this.error); // OR catchHandler(this.value)\n\t\t}\n\t\treturn this;\n\t}\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"So we are done? Let's try running this, and we'll uncover 2 major issues."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"console screenshot",src:s(3731).Z+"",width:"3420",height:"1302"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["All our internal class fields are exposed. Apart from ",(0,n.jsx)(t.code,{children:"then"})," & ",(0,n.jsx)(t.code,{children:"catch"})," we don't want anything else to be accessible. (Like in promises)"]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:"IT'S BROKEN!"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["I understand my priorities are not in the right order, but these are manageable issues. The extra exposed class fields can be obfuscated by using ",(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties",children:"private fields"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"The error is a very familiar one, if you've ever dealt with closures or context is javascript."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"{6} showLineNumbers",children:"class MyPromise {\n\t//same as before\n\tconstructor(callback){\n\t\tfunction resolve(val) { // same as before }\n\t\tfunction reject(err) { // same as before }\n\t\tcallback(resolve.bind(this), reject.bind(this))\n\t}\n\t// same as before\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Why does this happen? the callbacks supplied to callback run in a different context. They loose the reference to ",(0,n.jsx)(t.code,{children:"this"}),", hence cannot call or access any class fields they might depend upon. Another way to fix this would be to use arrow functions."]}),"\n",(0,n.jsx)(t.p,{children:"That's it. Your promise base class is now ready! \ud83e\udd73"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"class MyPromise {\n\t#onResolve; \n\t#onReject; \n\t#isFulfilled = false;\n\t#isRejected = false;\n\t#isCalled = false;\n\t#value;\n\t#error;\n\t\n\tconstructor(executor) {\n\t\tfunction resolve(val){\n\t\t\tthis.#isFulfilled = true;\n\t\t\tthis.#value = val;\n\t\t\tif(typeof this.#onResolve === 'function' && !this.#isCalled){\n\t\t\t\tthis.#isCalled = true;\n\t\t\t\tthis.#onResolve(val);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction reject(err){\n\t\t\tthis.#isRejected = true;\n\t\t\tthis.#error = err;\n\t\t\tif(typeof this.#onReject === 'function' && !this.#isCalled){\n\t\t\t\tthis.#isCalled = true;\n\t\t\t\tthis.#onReject(err);\n\t\t\t}\n\t\t}\n\t\t\n\t\texecutor(resolve.bind(this), reject.bind(this));\n\t}\n\n\tthen(thenHandler){\n\t\tthis.#onResolve = thenHandler;\n\t\tif(!this.#isCalled && this.#isFulfilled){\n\t\t\tthis.#isCalled = true;\n\t\t\tthis.#onResolve(this.#value);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcatch(catchHandler) {\n\t\tthis.#onReject = catchHandler;\n\t\tif(!this.#isCalled && this.#isRejected){\n\t\t\tthis.#isCalled = true;\n\t\t\tthis.#onReject(this.#error);\n\t\t}\n\t\treturn this;\n\t}\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Here are some things you could try to test yourself"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["try to implement this yourself with ",(0,n.jsx)(t.code,{children:"function"})," (i.e. without using ",(0,n.jsx)(t.code,{children:"class"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["accomodate ",(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally",children:(0,n.jsx)(t.code,{children:".finally"})}),". (We'll be needing this for one of the methods)"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["With this behind us, let's write the polyfills for the static methods. ",(0,n.jsx)(t.code,{children:"Promise.resolve"})," and ",(0,n.jsx)(t.code,{children:"Promise.reject"})," are the only ones that run against a value. ",(0,n.jsx)(t.code,{children:"Promise.all"}),", ",(0,n.jsx)(t.code,{children:"Promise.race"}),", ",(0,n.jsx)(t.code,{children:"Promise.allSettled"})," Let's start with the easy ones"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h3,{id:"promiseresolve",children:(0,n.jsx)(t.code,{children:"Promise.resolve"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"Promise.resolve"})," resolves a value to a promise."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.resolve = function(val) {\n\treturn new MyPromise(resolve => resolve(val));\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"promisereject",children:(0,n.jsx)(t.code,{children:"Promise.reject"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"Promise.reject"})," rejects a value to a promise."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.resolve = function(err) {\n\treturn new MyPromise((_, reject) => reject(err));\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"promisewithresolvers",children:(0,n.jsx)(t.code,{children:"Promise.withResolvers"})}),"\n",(0,n.jsxs)(t.p,{children:["This method, takes no parameters, and returns an object containing ",(0,n.jsx)(t.code,{children:"promise"}),", ",(0,n.jsx)(t.code,{children:"resolve"})," and ",(0,n.jsx)(t.code,{children:"reject"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.withResolvers = function(){\n\tlet resolve, reject;\n\tconst promise = new MyPromise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {resolve, reject, promise};\n}\n"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.admonition,{title:"edge case to consider remaining methods",type:"info",children:(0,n.jsx)(t.p,{children:"All promise methods that accept array of promises, accept empty array as input."})}),"\n",(0,n.jsx)(t.h3,{id:"promiserace",children:(0,n.jsx)(t.code,{children:"Promise.race"})}),"\n",(0,n.jsx)(t.p,{children:"This method accepts an array of promises, returns a single promise that resolves or rejects when any one of them fulfils or rejects."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.race = function(promises) {\n\treturn new MyPromise((resolve, reject) => {\n\t\tpromises.forEach(task => {\n\t\t\tMyPromise.resolve(task)\n\t\t\t\t.then(resolve)\n\t\t\t\t.catch(reject);\n\t\t});\n\t});\n}\n"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.admonition,{title:"edge case to consider remaining methods",type:"info",children:(0,n.jsx)(t.p,{children:"The order in which promises are resolve or rejected are persisted. Because there are no guarantees of promises arriving at a done state another, you cannot create an array and push values as you resolve (or reject) to them. They have to be added at the right indexes."})}),"\n",(0,n.jsx)(t.h3,{id:"promiseall",children:(0,n.jsx)(t.code,{children:"Promise.all"})}),"\n",(0,n.jsx)(t.p,{children:"This method accepts and array of promises, returns a single promise that resolves when all promises fulfil, and fails when any one of them fails."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.all = function(promises) {\n\treturn new MyPromise((resolve, reject) => {\n\t\tif(!promises.length) {\n\t\t\tresolve([]);\n\t\t}\n\t\tconst resolved = [];\n\t\tlet resolveCount = 0;\n\t\tpromises.forEach((task, idx) => {\n\t\t\tMyPromise.resolve(task)\n\t\t\t\t.then(value => {\n\t\t\t\t\tresolved[idx] = value;\n\t\t\t\t\tresolveCount++;\n\t\t\t\t\tif(resolveCount === iterable.length){\n\t\t\t\t\t\tresolve(resolved);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(reject);\n\t\t});\n\t});\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"promiseany",children:(0,n.jsx)(t.code,{children:"Promise.any"})}),"\n",(0,n.jsxs)(t.p,{children:["This method accepts an array of promises, returns a single promise that resolves with the first promise that fulfils, else rejects with an ",(0,n.jsx)(t.code,{children:"AggregateError"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:"MyPromise.any = function(promises) {\n\treturn new MyPromise((resolve, reject) => {\n\t\tif(!promises.length) {\n\t\t\treject(new AggregateError([]));\n\t\t}\n\t\tconst errors = [];\n\t\tlet errorCount = 0;\n\t\tpromises.forEach((task, idx) => {\n\t\t\tMyPromise.resolve(task)\n\t\t\t\t.then(resolve)\n\t\t\t\t.catch(error => {\n\t\t\t\t\terrors[idx] = error;\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tif(errorCount === promises.length){\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\t});\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"promiseallsettled",children:(0,n.jsx)(t.code,{children:"Promise.allSettled"})}),"\n",(0,n.jsx)(t.p,{children:"This method accepts an array of promises, and returns a promise that (always) resolves with status of each promise and value (or reason) of each of them."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"showLineNumbers",children:'// don\'t run this without implementing `.finally` on MyPromise\nMyPromise.allSettled = function(promises){\n\treturn new MyPromise(resolve => {\n\t\tif(!promises.length) {\n\t\t\tresolve([]);\n\t\t}\n\t\tlet calledCount = 0;\n\t\tconst results = [];\n\t\tpromises.forEach((task, idx) => {\n\t\t\t// Use native Promise if `.finally` isn\'t implemented\n\t\t\tMyPromise.resolve(task) \n\t\t\t\t.then(value => {\n\t\t\t\t\tresults[idx] = {status: "fulfilled", value};\n\t\t\t\t})\n\t\t\t\t.catch(reason => {\n\t\t\t\t\tresults[idx] = {status: "rejected", reason};\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tcalledCount++;\n\t\t\t\t\tif(calledCount === promises.length){\n\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\t});\n}\n'})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",children:"Promises"})}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",children:"class"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties",children:"private properties"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields",children:"public properties"})}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError",children:"AggregateError"})}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"That about it!"})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},3731:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/broken-promise-polyfill-17dd5a507b4993de4929023fc436bea4.png"},1151:(e,t,s)=>{s.d(t,{Z:()=>l,a:()=>i});var n=s(7294);const r={},o=n.createContext(r);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);